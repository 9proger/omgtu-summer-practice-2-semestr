#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №9. Реализация длительных операций.

**Цель:** Предоставить возможность выполннеия команд, для полного завершения которых требуется более одного вызова Execute.

**Результаты:** После выполнения работы Вы сможете:
1. Выполнять длительные опреации в отдельном потоке без монопольного использования потока в течение длительного времени.
3. Прерывать выполнение таких команд. 


## Задание.
Если для полного выполнения командв потребуется более одного вызова Execute, необходимо такую команду добавить в планировщик.

Для иллюстрации выполнненой работы определить команду

#!csharp

public interface ICommand
{
    void Execute();
    int CountOperation{get; set;}
}

#!csharp

public interface IScheduler
{
    bool HasCommand();
    ICommand Select();
    void Add(ICommand cmd);
}

#!csharp

using System.Collections.Concurrent;
class Scheduler : IScheduler
{
    ConcurrentQueue<ICommand> commandQueue = new ConcurrentQueue<ICommand>();
public bool HasCommand()
{
    if (commandQueue.Count>0)
    return true;
    return false;
}
public ICommand Select()
{
    if (commandQueue.TryDequeue(out ICommand command) && command.CountOperation>0)
    {
        return command;
    }
    return null;
}
public void Add(ICommand cmd)
{
    commandQueue.Enqueue(cmd);
}
}

#!csharp

using System.Threading;
public class ServerThread
{
    IScheduler sheduler;
    bool Hard = false;
    bool Soft = false;
    Thread thread;

    public ServerThread(IScheduler sheduler)
    {
        this.sheduler=sheduler;
        thread = new Thread(ExecuteCommands);
        thread.Start();
    }
    public void ExecuteCommands()
    {

        while (true)
        {
            ICommand nextCommand;

                if (sheduler.HasCommand() && !Hard)
                {
                    nextCommand = sheduler.Select();
                }
                else
                {
                    if (Soft || Hard)
                    {
                        break;
                    }
                    else
                    {
                        continue;
                    }
                }

            try
            {
                nextCommand.Execute();
                if (nextCommand.CountOperation>0)
                sheduler.Add(nextCommand);


            }
            catch (Exception ex)
            {}
        }
    }

    public void HardStop()
    {
        Hard = true;
    }

    public void SoftStop()
    {
         Soft = true;
    }
    public Thread GetThread() => thread;
}

#!csharp

public class MyCommand(int Count) : ICommand
{
public int CountOperation{get; set;}=Count;
int id = Thread.CurrentThread.ManagedThreadId;
public void Execute()
{
    Console.WriteLine("Обработка из потока {0}. Сколько осталось Exute для длительной комманды {1}",id,CountOperation);
    CountOperation--;
}

}

#!csharp

public class HardStop : ICommand
{
    ServerThread  Stop;
    public int CountOperation{get; set;} = 1;
    public HardStop(ServerThread thr)
    {
        Stop = thr;
    }
    public void Execute()
    {
        if (Thread.CurrentThread == Stop.GetThread())
        {
            CountOperation--;
            Stop.HardStop();
            Console.WriteLine("Обработка HardStop");
        }
    }
}

#!csharp

public class SoftStop : ICommand
{
    ServerThread Stop;
    public int CountOperation{get; set;} = 1;
    public SoftStop(ServerThread Stop)
    {
        this.Stop = Stop;
    }
    public void Execute()
    {
        if (Thread.CurrentThread == Stop.GetThread())
        {
            CountOperation--;
            Stop.SoftStop();
            Console.WriteLine("Обработка SoftStop");
        }
    }
}

#!csharp

using System.Threading;
Scheduler sched = new Scheduler();
ServerThread serverThread = new ServerThread(sched);

for (int i=0;i<5;i++)
{
      sched.Add(new MyCommand(3)); //Длительная комманда, разбитая на 3 Execute
}
Thread.Sleep(1);
sched.Add(new MyCommand(3)); 
sched.Add(new HardStop(serverThread));
sched.Add(new MyCommand(3)); 
serverThread.GetThread().Join();

#!markdown

Необходимо проиллюстрировать выполнение 5 экземпляров TestCommand 3 раза, затем остановить поток с помощью HardStop.
