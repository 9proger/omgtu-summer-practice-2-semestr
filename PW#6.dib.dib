#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №6. Изучение производительности потоко-безопасных очередей.

**Цель:** Определить лучшую потоко-безопасную коллекцию для выполнения интенсивной обработки входящих сообщений.

**Результаты:** После выполнения работы Вы сможете:
1. Назвать оптимальную коллекцию для обработки большого количества сообщений.
2. Изучите примтив синхронизации Условная переманная.


**Материалы для самостоятельного изучения**.
1. [Потоко-безопасные коллекции](https://learn.microsoft.com/en-us/dotnet/standard/collections/thread-safe/)
2. Условные переменные Глава 5 п.5.1. книги Г. Эндрюс Основы многопоточного, параллельного и распределенного программирования
3. [Одна из реализаций условных переменных на .Net](https://learn.microsoft.com/ru-ru/dotnet/api/system.threading.manualresetevent?view=net-8.0)

## Задание.
Исслдеовать производительность BlockingCollection и ConcurrentQueue в сравнении с непотокоабезопасной очередью.

Для каждой потоко-безопасной очереди необходимо реализовать 2 потока: один записывает объект в очередь, а другой - читает объект из очереди.
Для непотокобезопасной очереди реализовать два цикла - записи миллиона объектов в очередь и чтение миллиона объектов из очереди.

Необходимо определить два промежутка времени:
- время за которое поток или цикл обработает миллион объектов
- время, необходимое на запись и чтение миллиона объектов из очреди.

Сделать десять замеров по каждой коллекции. Все замеры показать на графике.

Записать в ноутбуке вывод - какая и потоко-безопасных коллекций эффективнее. И выразить в процентах - скорость самой быстрой поток-безопасной коллекции по сравнению с обычной очредью.

**Указание**.
1. Необходимо исключить из замеров время, необходимое для запуска и остановки потоков, то есть посчитать чистое время, необходимое для обработки объектов.
Для этого следует использовать условные события, которые позволят убедиться, что оба потока запустились и готовы читать и писать объекты и только потом запускать таймер.
2. Для итогового вывода сравнивать усредненные значения.

#!csharp

#r "nuget:ScottPlot, 5.0.35"
using System.Threading;
using System.Diagnostics;
using System.Collections.Concurrent;
using Microsoft.DotNet.Interactive.Formatting;
Formatter.Register(typeof(ScottPlot.Plot), (p, w) => 
    w.Write(((ScottPlot.Plot)p).GetImageHtml(400, 300)), HtmlFormatter.MimeType);
ScottPlot.Plot plt = new();
ScottPlot.Plot plt1 = new();
ScottPlot.Plot plt2 = new();
private static ManualResetEvent mre = new ManualResetEvent(false);
var BlCol = new BlockingCollection<int>(2);
var ConQue = new ConcurrentQueue<int>();
int AllStart=0;
bool AllWrt =false;
Stopwatch Time = new Stopwatch();
Thread[] BlockW = new Thread[10];
Thread[] BlockR = new Thread[10];
Thread[] ConcurrentW = new Thread[10];
Thread[] ConcurrentR = new Thread[10];
for (int i=0;i<10;i++){
BlockW[i] = new Thread(()=>{ // Запись BlockW
    int indexW=0;
    Interlocked.Increment(ref AllStart);
    mre.WaitOne();
    while(indexW!=1000000)
    {
        BlCol.Add(indexW+5);
        indexW++;
    }
    BlCol.CompleteAdding();

});
BlockR[i] = new Thread(()=>{ // Чтение BlockR
    int dataB;
    Interlocked.Increment(ref AllStart);
    mre.WaitOne();
    while(!BlCol.IsAddingCompleted)
    {
        try
        {
            dataB = BlCol.Take();
        }
        catch (InvalidOperationException) { }
        
    }
    });
ConcurrentW[i] = new Thread(()=>{// Запись ConcurrentW
    AllWrt=false;
    int indexWQ=0;
    Interlocked.Increment(ref AllStart);
    mre.WaitOne();
    while(indexWQ!=1000000)
    {
        ConQue.Enqueue(indexWQ);
        indexWQ++;
    }
    AllWrt=true;
});
ConcurrentR[i] = new Thread(()=>{ // Чтение ConcurrentR
    int dataQ;
    int data=0;
    Interlocked.Increment(ref AllStart);
    mre.WaitOne();
    while(AllWrt!=true)
    {
    while(ConQue.TryDequeue(out dataQ))
    {
        data+=dataQ;
    }
    }
});
}
double[] dataX = new double[10]; 
double[] dataY = new double[10];
double SumBlock=0;
for (int i=0;i<10;i++){//Тест времени для BlockingCollection
BlockW[i].Start();
BlockR[i].Start();
Thread.Sleep(100);
if (AllStart%2==0)
{
    Time.Start();
    mre.Set();
    BlockW[i].Join();
    BlockR[i].Join();
    Time.Stop();
}
dataX[i]=i+1;
dataY[i]=Time.ElapsedMilliseconds;
SumBlock += Time.ElapsedMilliseconds;
BlCol = new BlockingCollection<int>(2);
Time.Reset();
mre.Reset();
}
plt.Add.Scatter(dataX, dataY);
double[] dataX1 = new double[10]; 
double[] dataY1 = new double[10];
double SumCurQue=0;
for (int i=0;i<10;i++){ //Тест времени для ConcurrentQueue
ConcurrentW[i].Start();
ConcurrentR[i].Start();
Thread.Sleep(200);
if (AllStart%2==0)
{
    Time.Start();
    mre.Set();
    ConcurrentW[i].Join();
    ConcurrentR[i].Join();
    Time.Stop();
}
SumCurQue += Time.ElapsedMilliseconds;
ConQue = new ConcurrentQueue<int>();
dataX1[i]=i+1;
dataY1[i]=Time.ElapsedMilliseconds;
Time.Reset();
mre.Reset();
}
plt1.Add.Scatter(dataX1, dataY1);
Time.Reset();

double[] dataX2 = new double[10]; 
double[] dataY2 = new double[10];
double SumQue=0;
for (int i=0; i<10;i++) //Тест времени для Queue
{
    Time.Start();
    Queue Que = new Queue();
    for (int j=0; j<1000000;j++)
    {
        Que.Enqueue(j);
    }
    for (int j=0; j<1000000;j++)
    {
        Que.Dequeue();
    }
    Time.Stop();
    SumQue +=Time.ElapsedMilliseconds;
    dataX2[i]=i+1;
    dataY2[i]=Time.ElapsedMilliseconds;
    Time.Reset();
}
plt2.Add.Scatter(dataX2, dataY2);
Console.WriteLine("Среднее время выполнения BlockingCollection: {0}",SumBlock/10);
Console.WriteLine("Среднее время выполнения ConcurrentQueue: {0}",SumCurQue/10);
Console.WriteLine("Среднее время выполнения Queue: {0}",SumQue/10);
Console.WriteLine("Разница между многопоточным и однопоточным вариантом составляет: {0} процента(ов)",Math.Round(((SumQue/10)*100)/(SumCurQue/10)));

#!csharp

plt //График BlockingCollection

#!csharp

plt1 //График ConcurrentQueue

#!csharp

plt2 //График Queue

#!markdown

## Вывод
