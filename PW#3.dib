#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №1. Знакомство с потоками.

**Цель:** Познакомиться с возможностями класса System.Thread платформы .NET Framework.

**Результаты:** После выполнения работы Вы сможете:
1. Запускать длительные операции в отдельном потоке.
2. Завершать поток.
3. Дожидаться завершения выполнения потока. 


**Материалы для самостоятельного изучения**.
1. [Основы управления потоками](https://learn.microsoft.com/en-us/dotnet/standard/threading/managed-threading-basics)
2. [Использование потоков](https://learn.microsoft.com/en-us/dotnet/standard/threading/using-threads-and-threading)
3. [Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier)
4. [Interlocked операции](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0)

## Задание.
Реализовать вычисление определенного интеграла методом трапеции в несколько потоков.

Отрезок, на котором происходит вычисление, разбивается на отрезки по количеству потоков. Для каждого отрезка значение 
интеграла считается в отдельном потоке, после завершения вычисоения полученный рельтаты суммирутся.

**Указание**.
1. Для суммирования результатов удобно воспользоваться разделяемой переменной, к которой будут прибалятся результаты вычисления прямо в самом потоке. Для синхронизации операций сложения лучше всего восользоваться [Interlocked операцией](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0).
2. Основная функция долна дождаться завершения всех потоков, которые вычисляют значение на отрезках, прежде чем возвратить результат. Для этого удобнее всего использовать Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier).

#!csharp

//
// Вычисление определенного интеграла
//
using System.Threading;
class DefiniteIntegral
{
    //
    // a, b - границы отрезка, на котором происходит вычисление опредленного интеграла
    // function - функция, для которой вычисляется определнный интеграл
    // step - размер одного шага разбиения
    // threadsNumber - число потоков, которые используются для вычислений
    //
    public static double Solve(double a, double b, Func<double, double> function, double step, int threadsnumber)
    {
        double sum = 0.0;
        Barrier barrier = new Barrier(threadsnumber);
        Thread[] sol = new Thread[threadsnumber];
        for(int j = 0; j < threadsnumber; j++)
            {
                int orderthr=j;
                sol[j] = new Thread(()=>{
                    object locker = new();
                    double midsum=0.0;
                    for (double i=a+(step*(orderthr+1)); i<=b; i+=threadsnumber*step)
                    {
                    midsum = midsum+((function(i)+function(i-step))/2)*step;
                    }
                    lock(locker)
                    {
                        sum+=midsum;
                    }
                    barrier.SignalAndWait();
                });
                sol[j].Start();             
            }
        for(int index = 0; index < threadsnumber; index++){
                sol[index].Join();
            }   
        return sum;
    }
    
}

#!csharp

#r "nuget: xunit, 2.8.1"
#r "nuget:ScottPlot, 5.0.35"
using System.Diagnostics;
using Xunit;
using Microsoft.DotNet.Interactive.Formatting;
Formatter.Register(typeof(ScottPlot.Plot), (p, w) => 
    w.Write(((ScottPlot.Plot)p).GetImageHtml(400, 300)), HtmlFormatter.MimeType);
Stopwatch Time = new Stopwatch();
ScottPlot.Plot plt = new();
double summarytime=0;
double[] dataX = new double[8]; 
double[] dataY = new double[8];
var SIN = (double x) => Math.Sin(x);
for (double i =1e-1;i>=1e-6;i=i/10){//Вычисление времени для каждого шага
Time.Start();
Assert.Equal(0, DefiniteIntegral.Solve(-100, 100, SIN, i, 8), 1e-4);
Time.Stop();
Console.WriteLine("Вычисленное время {0} с шагом {1}",Time.Elapsed,i);
Time.Reset();
}
for (int j = 2; j<10 ; j++){//Вычисление усреднённого времени для разного количества потоков по оптимально выбранному шагу для моей программы (1e-4)
    summarytime=0;
    for (int k=0;k<=9;k++)
    {
        Time.Start();
        Assert.Equal(0, DefiniteIntegral.Solve(-100, 100, SIN, 1e-4, j), 1e-4);
        Time.Stop();
        summarytime+=Time.ElapsedMilliseconds;
        //Console.WriteLine(Time.Elapsed+"Elapsed");
        Console.WriteLine("Вычисленное время {0} с количеством потоков {1}",Time.ElapsedMilliseconds,j);
        Time.Reset();

    }
    //Console.WriteLine(summarytime/10+"Summary");
    dataX[j-2]=summarytime/10;
    dataY[j-2]=j;
}
plt.Add.Scatter(dataX, dataY);
plt

#!csharp

#r "nuget: xunit, 2.8.1"
using System.Diagnostics;
using Xunit;
Stopwatch Time = new Stopwatch();
var SIN = (double x) => Math.Sin(x);
double a = -100;
double b = 100;
double step = 1e-4;
double midsum=0.0;
Time.Start();
for (double i=a+step; i<=b; i+=step)
                    {
                    midsum = midsum+((SIN(i)+SIN(i-step))/2)*step;
                    }
Time.Stop();
Console.WriteLine("Вычисленное время {0}",Time.Elapsed);
Console.WriteLine("Вычисленное время {0}",Time.ElapsedMilliseconds);
